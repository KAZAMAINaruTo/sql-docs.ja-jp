## <a name="pacemakerNotify"></a>ペースに対する SQL Server エージェントのリソースを理解します。

CTP 1.4 リリースより前に可用性グループのペース リソース エージェントでした認識していないかどうか、レプリカとしてマーク`SYNCHRONOUS_COMMIT`本当に最新の状態であるか。 レプリカがプライマリとの同期を停止していても、それを認識していない可能性がありました。 したがって、エージェントは、なり、成功した場合、データの損失をプライマリに古くなったレプリカを昇格させる可能性があります。 

SQL Server 2017 CTP 1.4 追加`sequence_number`に`sys.availability_groups`この問題を解決するためにします。 `sequence_number`ローカルの可用性グループのレプリカの可用性グループ内のレプリカの残りの部分に対して最新であるかを表す単調に増加する BIGINT です。 フェールオーバーの実行の追加、またはレプリカ、およびその他の可用性グループの操作を削除は、この番号を更新します。 数が、プライマリ上で更新し、セカンダリ レプリカにプッシュします。 したがって、最新の状態であるセカンダリ レプリカはプライマリと同じ sequence_number があります。 

最初にシーケンス番号を抽出し、保存のすべてのレプリカに通知を送信それをプライマリ レプリカを昇格するペースが決定したら、(これを呼び出して、事前の通知を昇格)。 次に、ペースが実際には、レプリカはプライマリに昇格しようとするとき、レプリカだけ昇格自体のシーケンス番号は、すべてのレプリカからのすべてのシーケンス番号の最大値と、それ以外の場合、昇格操作は拒否します。 この方法により、最大のシーケンス番号を持つレプリカだけがプライマリに昇格できるようになるため、データの損失が回避されます。 

ただしこれは、昇格の対象となるレプリカのうち少なくとも 1 つが、以前のプライマリと同じシーケンス番号を持っている場合にのみ保証されます。 これには、既定の動作ペース リソースではエージェントは自動的に設定する`REQUIRED_COPIES_TO_COMMIT`を少なくとも 1 つに同期コミット セカンダリ レプリカに最新の状態とは使用する、自動フェールオーバーのターゲットにします。 各監視のアクションでは、値`REQUIRED_COPIES_TO_COMMIT`計算 (および必要に応じて更新) として ('個の同期コミット レプリカの'/2)。 次に、フェールオーバー時に、リソースのエージェントが必要になります (`total number of replicas`  -  `required_copies_to_commit`レプリカ) に応答する、事前にプライマリにそれらのいずれかを昇格させることが通知を昇格します。 最高の値を持つレプリカ`sequence_number`プライマリに昇格されます。 

たとえば、次の 3 つの同期レプリカの 1 つのプライマリ レプリカと 2 つの同期コミット セカンダリ レプリカを可用性グループの場合について考えてみましょう。

- `REQUIRED_COPIES_TO_COMMIT`3/2 = 1

- 必要なアクションを昇格させる前に応答するレプリカ数は 3-1 = 2 です。 フェールオーバーをトリガーするためにする必要は、2 つのレプリカです。 つまり、プライマリの停止の場合、セカンダリ レプリカのいずれかが応答していないと、セカンダリの 1 つのみに応答する場合、事前昇格アクション、リソース エージェントは、応答したセカンダリが最高の sequence_number され、フェールオーバーがトリガーされないことを保証ことはできません。

既定の動作をオーバーライドし、可用性グループ リソースの構成を設定しないように、ユーザーが選択できる`REQUIRED_COPIES_TO_COMMIT`自動的に上記と同じです。

>[!IMPORTANT]
>ときに`REQUIRED_COPIES_TO_COMMIT`0 はデータ損失のリスクがします。 プライマリが停止した場合、リソースのエージェントは自動的にトリガーされませんフェールオーバー。 ユーザーは、プライマリ サイトへの回復または手動でフェールオーバーするまで待機するかどうかを決定しています。

設定する`REQUIRED_COPIES_TO_COMMIT`0 の場合に実行します。

```bash
sudo pcs resource update <**ag_cluster**> required_copies_to_commit=0
```

(SLES での) crm の使用と同等のコマンドを、次に示します。

```bash
sudo crm resource param <**ag_cluster**> set required_synchronized_secondaries_to_commit 0
```

既定値に戻すには計算値、実行されます。

```bash
sudo pcs resource update <**ag_cluster**> required_copies_to_commit=
```

>[!NOTE]
>リソースのプロパティを更新すると、すべてのレプリカを停止して再起動します。 このプライマリは、意味は一時的に、セカンダリに降格しを器の一時的な記述が使用できなくなるをもう一度昇格します。 REQUIRED_COPIES_TO_COMMIT の新しい値のみ設定されますレプリカを再開すると、pc コマンド実行の瞬間的なことができなくようにします。

## <a name="balancing-high-availability-and-data-protection"></a>高可用性とデータ保護の分散 

上記の既定の動作は、2 つの同期レプリカ (プライマリとセカンダリ) の場合にも適用されます。 既定でペース`REQUIRED_COPIES_TO_COMMIT = 1`して、セカンダリ レプリカは常に最新の状態最大データ保護のためです。  

>[!WARNING]
>これが付属の計画または計画外の障害によってプライマリ レプリカが使用できなくなるリスクが高く、セカンダリでします。 ユーザーがリソースのエージェントの既定の動作を変更し、上書きを選択できる、`REQUIRED_COPIES_TO_COMMIT`を 0 にします。

```bash
sudo pcs resource update <**ag1**> required_copies_to_commit=0
```

リソース エージェントでの新しい設定を使用してオーバーライドされると、一度`REQUIRED_COPIES_TO_COMMIT`および計算が停止します。 これは、手動で更新してそれに従って (たとえば、これらは、レプリカの数を増やす) 場合にユーザーがあることを意味します。

次の表では、別の可用性グループ リソース構成のプライマリまたはセカンダリ レプリカの停止によって生じる結果について説明します。

### <a name="availability-group---2-sync-replicas"></a>可用性グループの 2 つの同期レプリカ

| |プライマリの停止 |1 つのセカンダリ レプリカの停止
|:---|:--- |:--- |
|`REQUIRED_COPIES_TO_COMMIT=0`|手動フェールオーバーを発行するユーザーが持っています。 <br>データが失われる場合があります。<br> 新しいプライマリが読み取り/書き込みです。 |プライマリが読み取り/書き込み、データの損失を不安定な実行
|`REQUIRED_COPIES_TO_COMMIT=1` * |クラスターがフェールオーバーを自動的に発行されます。 <br>データ損失なし。 <br> 新しいプライマリには、前のプライマリが復旧し、セカンダリ可用性グループに参加するまでにすべての接続は拒否します。 |プライマリがセカンダリあって回復するまでのすべての接続を拒否します。

\*ペースの既定の動作の SQL Server リソース エージェント。

### <a name="availability-group---3-sync-replicas"></a>可用性グループ - 3 つの同期レプリカ

| |プライマリの停止 |1 つのセカンダリ レプリカの停止
|:---|:--- |:--- |
|`REQUIRED_COPIES_TO_COMMIT=0`|手動フェールオーバーを発行するユーザーが持っています。 <br>データが失われる場合があります。 <br>新しいプライマリが読み取り/書き込みです。 |プライマリ ファイル グループは読み取り/書き込みです。
|`REQUIRED_COPIES_TO_COMMIT=1` * |クラスターでは、フェールオーバーを自動的に発行されます。 <br>データ損失なし。 <br>新しいプライマリが RW |プライマリ ファイル グループは読み取り/書き込みです。 

\*ペースの既定の動作の SQL Server リソース エージェント。