---
title: "SQL Server の構成 (R Services) | Microsoft Docs"
ms.custom: 
ms.date: 07/26/2017
ms.prod: sql-server-2016
ms.reviewer: 
ms.suite: 
ms.technology: r-services
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: 4b08969f-b90b-46b3-98e7-0bf7734833fc
caps.latest.revision: "13"
author: jeannt
ms.author: jeannt
manager: jhubbard
ms.workload: Inactive
ms.openlocfilehash: 486c0d2772660d4a549e3ebdf29e2cd54ace3d01
ms.sourcegitcommit: 9678eba3c2d3100cef408c69bcfe76df49803d63
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/09/2017
---
# <a name="sql-server-configuration-for-use-with-r"></a>R で使用するための SQL Server の構成

この記事では、次の 2 つのケース スタディに基づいて R Services のパフォーマンスの最適化を説明するシリーズの 2 つ目はします。  この記事では、SQL Server R Services を実行するために使用するコンピューターのハードウェアおよびネットワークの構成に関するガイダンスを提供します。 SQL Server インスタンス、データベース、またはソリューションで使用されるテーブルを構成する方法に関する情報も含まれています。 SQL Server での NUMA の使用は、ハードウェアとデータベースの最適化の間の線をぼかす、ために、3 番目のセクションには、詳細で、CPU の結合とリソース ガバナンスがについて説明します。

> [!TIP]
> SQL Server に慣れていない場合を強くお勧め、SQL Server のパフォーマンス チューニングのガイドを確認すること。[モニターとパフォーマンスのチューニング](https://docs.microsoft.com/sql/relational-databases/performance/monitor-and-tune-for-performance)です。

## <a name="hardware-optimization"></a>ハードウェアの最適化

サーバー コンピューターの最適化は、外部のスクリプトを実行するリソースがあることを確認する場合に重要です。 リソースが不足しているときにこのような現象が発生する可能性があります。

- ジョブの実行が遅延またはその他のデータベース操作の優先順位をキャンセル
- 原因の R スクリプトを完了する前に終了するエラー「クォータを超過しました」
- 不完全な結果を得るには、切り捨て R メモリに読み込まれるデータ

### <a name="memory"></a>[メモリ]

コンピューター上で利用できるメモリの量は、高度な分析アルゴリズムのパフォーマンスに大きな影響を与える場合があります。 メモリが不足してで、SQL compute context を使用する場合、並列処理の次数がしまう場合があります。 また、処理可能なチャンク サイズ (読み取り操作あたりの行数) や、サポートできる同時セッション数にも影響する可能性があります。

32 GB の最小値は強くお勧めします。 32 GB 以上使用可能な場合は、読み取り操作のたびに複数の行を使用して、パフォーマンスを向上させる SQL データ ソースを構成することができます。

インスタンスによって使用されるメモリを管理することもできます。 既定では、メモリが割り当てられている場合に SQL Server は外部スクリプトのプロセスよりも優先順位します。 R. に R Services の既定のインストールで使用可能なメモリの 20% のみが割り当てられています。

通常これは十分でないデータ サイエンス タスクが、どちらも実行する SQL server メモリの余裕ができすぎます。 テストし、データベース エンジン、関連するサービス、および最適な構成がケースに変化する理解したうえで、外部スクリプト間のメモリ割り当てを調整する必要があります。

再開-一致するモデルの外部スクリプトの使用が高いとがなかったその他のデータベース エンジン サービスが実行中です。したがって、スクリプトのパフォーマンスを最適な構成であった、70% に外部スクリプトに割り当てられたリソースが増加します。

### <a name="power-options"></a>電源オプション

Windows オペレーティング システム上、**高パフォーマンス**電源オプションを使用する必要があります。 別の電源設定を使用して結果パフォーマンスの低下や一貫性のない SQL Server を使用する場合。

### <a name="disk-io"></a>ディスク IO

トレーニングと R Services を使用して、ジョブは、本質的に IO 予測は、バインドされるとに、データベースが格納されているディスクの速度によって異なります。 ソリッド ステート ドライブ (SSD) などの高速のドライブが役立つ場合があります。

ディスク IO は、ディスクにアクセスする他のアプリケーションによっても影響を受けます (たとえば、データベースに対して読み取り操作を行う他のクライアントなど)。 またディスク IO のパフォーマンスは、使用されているファイル システムの設定によっても影響を受けることがあります (ファイル システムによって使用されるブロック サイズなど)。

複数のドライブが使用可能な場合は、SQL Server データベース エンジンを要求するため、別のドライブ上のデータベースと同じディスク ヒットいないストアは、データベースに格納されたデータを要求します。

トレーニング時に RevoScaleR 分析関数を繰り返し実行する場合も、ディスク IO がパフォーマンスに大きな影響を与える可能性があります。 たとえば、 `rxLogit`、 `rxDTree`、 `rxDForest`、および`rxBTrees`すべては、複数のイテレーションを使用します。 データ ソースが SQL Server の場合は、これらのアルゴリズムは、データをキャプチャできるように最適化された一時ファイルを使用します。 これらのファイルは、セッションの完了後に自動的にクリーンアップされます。 高パフォーマンスのディスク読み取り/書き込み操作のことと、これらのアルゴリズムの全体的な経過時間が大幅に向上します。

> [!NOTE]
> R Services の以前のバージョンでは、Windows オペレーティング システムの 8.3 ファイル名のサポートが必要です。 この制限は、Service Pack 1 の後に解除されました。 ただし、ドライブが 8.3 ファイル名をサポートしているかどうかを決定する、またはそうでない場合は、サポートを有効にする fsutil.exe を使用することができます。

### <a name="paging-file"></a>ページング ファイル

Windows オペレーティング システムでは、クラッシュ ダンプの管理や仮想メモリ ページの格納に、ページング ファイルが使用されます。 過度なページングに気付いた場合は、コンピューター上の物理メモリを増やすことを検討してください。 物理メモリを増やしてもページングがなくなるわけではありませんが、ページングの必要性が減ります。

ページ ファイルが格納されるディスクの速度も、パフォーマンスに影響する可能性があります。 ページ ファイルを SSD に格納したり、複数の SSD 間で複数のページ ファイルを使用すると、パフォーマンスを改善できる可能性があります。

ページファイルのサイズ変更方法の詳細については、次を参照してください。 [64 ビット バージョンの Windows の適切なページ ファイル サイズを調べる方法](https://support.microsoft.com/en-us/kb/2860880)です。

## <a name="optimizations-at-instance-or-database-level"></a>インスタンスまたはデータベース レベルでの最適化

SQL Server インスタンスの最適化とは、外部スクリプトの効率的に実行するキーです。

> [!NOTE]
> 最適な設定は、スコア付けまたはモデルのトレーニングに使用する列の数、データの種類とサイズによって異なります。
> 
> 最後の記事で特定の最適化の結果を確認することができます:[パフォーマンス チューニングのケース スタディ結果](../../advanced-analytics/r/performance-case-study-r-services.md)
> 
> サンプル スクリプトは、個別を参照してください。 [GitHub リポジトリ](https://github.com/Microsoft/SQL-Server-R-Services-Samples/tree/master/PerfTuning)です。

### <a name="table-compression"></a>テーブル圧縮

IO パフォーマンスには、圧縮または単票形式のデータ ストアを使用する多くの場合、改善できます。 一般に、データは多くの場合、繰り返され、テーブル内の複数の列で、データを圧縮するときに、これらの繰り返しの活用、列ストアを使用しています。

列ストア テーブルに多数の挿入がある場合に、効率的なことができない可能性がありますが、適切な選択が静的のデータまたはのみ変更頻度が低い場合。 列ストアが適切でない場合は、行メジャー テーブルでの圧縮を有効にすることで、IO を改善できる可能性があります。

詳しくは、次の各ドキュメントをご覧ください。

+ [データの圧縮](../../relational-databases/data-compression/data-compression.md)

+ [テーブルまたはインデックスで圧縮を有効にします。](../../relational-databases/data-compression/enable-compression-on-a-table-or-index.md)

+ [列ストア インデックス ガイド](../../relational-databases/indexes/columnstore-indexes-overview.md)

### <a name="memory-optimized-tables"></a>メモリ最適化テーブル

現在では、メモリは、最近のコンピューターの問題ではなくなりました。 ハードウェアの仕様、継続的に向上させるには適切な値に RAM を取得する比較的簡単です。 ただし、同時にデータが生成されたもので、これまでより簡単にし、短い待機時間でデータを処理する必要があります。

メモリ最適化テーブルは、ビッグ データの問題に取り組むために高度なコンピューターに使用可能な大規模なメモリを活用することで、1 つのソリューションを表します。 メモリ最適化テーブルは主に、メモリ内に存在できるように、データを読み取ったり、メモリに書き込まれます。 持続性の場合、テーブルの 2 番目のコピーがディスクに保持され、データがデータベースの復旧中にディスクから読み取るだけです。

読み取りと書き込みのテーブルに頻繁に必要がある場合、高いスケーラビリティと低待機時間とメモリ最適化テーブルを引き起こすことができます。  再開マッチングのシナリオでは、メモリ最適化テーブルの使用は、データベースからすべての再開機能を読み込むし、新しい求人に一致するように、メイン メモリに保存することを許可します。 これにより、ディスク IO が大幅に削減します。

複数の同時バッチから、データベースを戻す予測の作成中のメモリ最適化テーブルを使用してパフォーマンスを向上が実現しました。 SQL Server 上のメモリ最適化テーブルの使用には、テーブルの読み取りと書き込みの低待機時間が有効にします。

開発時に、エクスペリエンスをシームレスなでも。 持続性のあるメモリ最適化テーブルは、データベースが作成された、同時に作成されました。 そのため、開発では、データの格納場所に関係なく、同じワークフローが使用されます。

### <a name="processor"></a>プロセッサ

SQL Server は、コンピューターに使用可能なコアを使用して、並列タスクを実行することができます。複数のコア、使用可能なパフォーマンスは向上します。 コアの数を増やす場合がありますいない、役に立つバインド IO 操作の多くのコアを備えた高速な Cpu からアルゴリズムの利点が CPU にバインドします。

サーバーは通常使用されるため複数のユーザーが同時に、データベース管理者はピーク ワークロードの計算をサポートするために必要なコア数の最適なを決定する必要があります。

### <a name="resource-governance"></a>リソース管理:

リソース ガバナーをサポートするエディションでは、特定のワークロードが Cpu のいくつかの数を割り当てられているを指定するのにリソース プールを使用できます。 また、特定のワークロードに割り当てられたメモリの量を管理することができます。

SQL Server でリソース統制では、その r です。 SQL Server で使用されるさまざまなリソースの監視および制御を一元管理できます。たとえば、いるコア サービスは一時的な重いワークロードを行ってもいつでも実行できることを確認する、データベース エンジンの半分の使用可能なメモリを割り当てる可能性があります。

外部スクリプトによるメモリ消費の既定値は、SQL Server 自体の使用可能なメモリの合計の 20% に制限されます。 既定では、データベース サーバーに依存するすべてのタスクが深刻な影響を受けないこと長時間実行される R ジョブを確認してください。 には、この制限が適用されます。 ただし、これらの制限はデータベース管理者によって変更することもできます。 多くの場合では、20% の制限は重大なマシンのワークロードの学習をサポートするのに十分ではありません。

サポートされる構成オプションは**MAX_CPU_PERCENT**、 **MAX_MEMORY_PERCENT**、および**MAX_PROCESSES**です。 現在の設定を表示するには、このステートメントを使用します。`SELECT * FROM sys.resource_governor_external_resource_pools`

-  場合は、サーバーは、主に、R Services の使用、MAX_CPU_PERCENT を 40% または 60% まで増加すると役立つ場合があります。

-  多くの R セッションは、同時に同じサーバーを使用する必要がある場合、次の 3 つのすべての設定を増やす必要があります。

割り当てられたリソースの値を変更するには、T-SQL ステートメントを使用します。

+ このステートメントでは、メモリ使用量を 40% に設定します。`ALTER EXTERNAL RESOURCE POOL [default] WITH (MAX_MEMORY_PERCENT = 40)`

+ このステートメントは、次の 3 つすべての構成可能な値を設定します。`ALTER EXTERNAL RESOURCE POOL [default] WITH (MAX_CPU_PERCENT = 40, MAX_MEMORY_PERCENT = 50, MAX_PROCESSES = 20)`

+ メモリ、CPU、または max プロセス設定を変更し、設定をすぐに適用する場合は、このステートメントを実行します。`ALTER RESOURCE GOVERNOR RECONFIGURE`

## <a name="soft-numa-hardware-numa-and-cpu-affinity"></a>ソフト NUMA、ハードウェア NUMA、CPU アフィニティ

コンピューティング コンテキストとして SQL Server を使用して、NUMA、プロセッサ アフィニティに関連する設定をチューニングすることによってパフォーマンスを向上させることがあります実現できます。 

システムで_ハードウェア NUMA_プロセッサの小さなセットを提供している各 1 つ以上のシステム バスがあります。 各 CPU は、一貫した方法で他のグループに関連付けられているメモリにアクセスできます。 この CPU の各グループのことを NUMA ノードと呼びます。 ハードウェア NUMA を使用する場合は、NUMA ではなくインターリーブされたメモリを使用するように構成できます。 その場合は、Windows およびそのために SQL Server として認識しないこと NUMA です。 

SQL Server で使用できるメモリ ノードの数を検索する次のクエリを実行できます。

```SQL
SELECT DISTINCT memory_node_id
FROM sys.dm_os_memory_clerks
```

クエリでは、1 つのメモリ ノード (ノード 0) が返された場合は、ハードウェア NUMA、することはありませんか、ハードウェアがインターリーブ (非 NUMA) として構成されています。 SQL Server では、ハードウェア NUMA も無視されますと 4 つ以下の Cpu には、少なくとも 1 つのノードの CPU を 1 つだけの場合、または。

お使いのコンピューターが複数のプロセッサがハードウェア NUMA を持たない、使用することも[ソフト NUMA](https://docs.microsoft.com/sql/database-engine/configure-windows/soft-numa-sql-server) Cpu をより小さなグループに分割します。  SQL Server 2016 および SQL Server 2017 で SQL Server サービスを開始するときに自動的に、ソフト NUMA 機能が有効です。

ソフト NUMA を有効にすると、SQL Server は、ノードを自動的を管理します。ただし、特定のワークロードの最適化を無効にできます_ソフト アフィニティ_し、ソフト NUMA ノードの CPU 関係を手動で構成します。 これは、ことができますかを制御するワークロードはどのノードに割り当てリソース管理をサポートする SQL Server のエディションを使用している場合に特にです。 CPU 関係を指定して、Cpu のグループを含むリソース プールの整列、によって、待機時間を短縮し、関連するプロセスが、同じ NUMA ノード内で実行されていることを確認できます。

ソフト NUMA と R ワークロードをサポートするために CPU 関係を構成するため、全体的なプロセスは次のとおりです。

1. 使用可能な場合は、ソフト NUMA を有効にします。
2. プロセッサのアフィニティを定義します。
3. リソース プールを使用して、外部プロセス用に作成[リソース ガバナー](../r/resource-governance-for-r-services.md)
4. 割り当てる、[ワークロード グループ](../../relational-databases/resource-governor/resource-governor-workload-group.md)を特定のアフィニティ グループ

サンプル コードを含む詳細については、このチュートリアルを参照してください: [SQL 最適化ヒントとテクニック (Ke Huang)](https://gallery.cortanaintelligence.com/Tutorial/SQL-Server-Optimization-Tips-and-Tricks-for-Analytics-Services)

**その他のリソース:**

+ [SQL Server でソフト NUMA](https://docs.microsoft.com/en-us/sql/database-engine/configure-windows/soft-numa-sql-server)
    
    Cpu へのソフト NUMA ノードにマップする方法

+ [自動ソフト NUMA: 高速化 (Bob ワード) だけ実行されます](https://blogs.msdn.microsoft.com/bobsql/2016/06/03/sql-2016-it-just-runs-faster-automatic-soft-numa/)

   履歴をについて説明します。 以降のマルチコア サーバーでパフォーマンスの実装の詳細とします。

## <a name="task-specific-optimizations"></a>タスク固有の最適化

このセクションでは、これらのケース スタディでおよびワークロードを学習、特定のマシンを最適化するため、他のテストで採用しているメソッドをまとめたものです。 一般的なワークロードには、モデルのトレーニング、特徴を抽出し、特徴エンジニア リング、およびスコアリングのためのさまざまなシナリオが含まれます。 単一行、小さいバッチ、および大きなバッチ。

### <a name="feature-engineering"></a>機能エンジニアリング

R での 1 つの問題点は、1 つの CPU の処理は、通常です。 これは、多くのタスクの主要なパフォーマンスのボトルネック エンジニア リングを特に機能します。 再開の一致のソリューションでは、単独で、機能エンジニア リング タスクには、2,500 のクロス積機能元の 100 の機能と組み合わせてする必要があったが作成されます。 このタスクで、単一の CPU ですべてが完了した場合、かなりの時間がかかる場合があります。

これには特徴エンジニア リングのパフォーマンスを向上させるために複数の方法があります。 いずれか、R コードを最適化し、モデリング プロセス内の特徴抽出を保持したり、SQL 機能エンジニア リング プロセスに移動できます。

- 使用して r です。関数を定義しへの引数として渡す[rxTransform](https://docs.microsoft.com/r-server/r-reference/revoscaler/rxtransform)トレーニング中にします。 モデルでは、並列処理をサポートする場合、複数の Cpu を使用して機能のエンジニア リング タスクを処理できます。 このアプローチを使用して、データ サイエンス チームは時間をスコア付けの観点から 16% パフォーマンスが向上を確認します。 ただし、この方法では、並列処理と並列プランを使用して実行できるクエリをサポートするモデルが必要です。

- SQL と R を使用では、コンテキストを計算します。 個別のバッチの実行に利用できる分離されたリソースを使用するマルチプロセッサ環境では、バッチごとのテーブルからデータを抽出し、同一のワークロード グループのデータを制限するための SQL クエリを特定することで効率を実現できます。 バッチを分離するために使用メソッドは、パーティション分割を含めるし、別のクエリを並列に実行する PowerShell の使用します。

- アドホックの並列実行: SQL Server のコンピューティング コンテキストでは、並列実行可能な場合とそのオプションが見つからないかどうかはより効率的に適用するため、SQL データベース エンジンに依存することができます。

- 個別の特性付けプロセスで T-SQL を使用します。 SQL を使用して機能のデータをで一般的に高速です。

### <a name="prediction-scoring-in-parallel"></a>並列 (スコア付け) 予測

SQL Server の利点の 1 つは、膨大な並列内の行を処理する機能です。 含まれていませんがこの利点のため中 とマーク スコア付けします。 一般に、モデル必要はありませんすべてのデータへのアクセス、スコア付けのため、各ワークロード グループを 1 つのタスクを処理すると、入力データをパーティション分割することができます。

1 つのクエリとして、入力データを送信することもでき、SQL Server は、クエリを分析します。 入力データの並列クエリ プランを作成する場合に自動的にノードに割り当てられたデータをパーティション分割し、並列もに必要な結合と集計を実行します。

スコア付けで使用するためのストアド プロシージャを定義する方法の詳細に関心が場合は、サンプル プロジェクトを参照してください[GitHub](https://github.com/Microsoft/SQL-Server-R-Services-Samples/tree/master/SQLOptimizationTips/SQLR)し"step5_score_for_matching.sql"ファイルを探します。 サンプル スクリプトも追跡クエリの開始と終了時刻、および SQL コンソールにかかる時間の書き込みのパフォーマンスを評価できるようにします。

### <a name="concurrent-scoring-using-resource-groups"></a>リソース グループを使用して、同時実行のスコアリング

スコア付けの問題をスケールを設定するには、ことをお勧めは数百万のアイテムは複数のバッチに分けられます map-reduce アプローチを採用するです。 次に、複数のスコアリングのジョブは同時に実行します。 この framework でのバッチは、異なる CPU で処理され、結果が収集され、データベースに書き戻さです。

これは、再開-一致するシナリオで使用するアプローチです。ただし、SQL Server でリソース ガバナンスは、このアプローチの実装に不可欠です。 外部スクリプトのジョブのワークロード グループを設定すると、R ジョブを複数のプロセッサ グループにスコアをルーティングでき、スループットが向上することができます。

リソース管理にも役立ちますを割り当て、使用可能なサーバー上のリソース (CPU およびメモリ) のワークロードでの競合を最小限に抑えるに分割します。 分類子関数をセットアップするには、R ジョブの種類を区別する: たとえば、することができますを常に、アプリケーションから呼び出されるスコア付け優先順位、再トレーニング ジョブが優先度の低い。 このリソース分離は、実行時間を向上させるしより予測可能なパフォーマンスを提供することができます可能性があります。

### <a name="concurrent-scoring-using-powershell"></a>PowerShell を使用して、同時実行のスコアリング

自分でデータをパーティション分割する場合は、複数の同時実行のスコアリング タスクを実行する PowerShell スクリプトを使用できます。 これを行うには、Invoke-sqlcmd コマンドレットを使用し、並列でスコアリング タスクを開始します。

再開の一致では、同時実行はとおりしました。

- 20 のプロセッサは、5 つの Cpu の 4 つのグループに分割されます。 Cpu の各グループは、同じ NUMA ノードにあります。

- 同時バッチの最大数は 8 に設定されました。

- 各ワークロード グループには、2 つのスコア付けタスクを処理する必要があります。 データとスコアリング開始を読み取り中に 1 つのタスクが完了したら、すぐデータベースからデータを読み取り、別のタスクを開始できます。

このシナリオ用の PowerShell スクリプトを表示するでファイル experiment.ps1 を開き、 [Github プロジェクト](https://github.com/Microsoft/SQL-Server-R-Services-Samples/tree/master/SQLOptimizationTips)です。

### <a name="storing-models-for-prediction"></a>予測モデルを格納します。

トレーニングと評価が完了すると、最適なモデルを選択したときに、データベースに格納する、モデルの予測に使用できるようにお勧めします。 予測のデータベースからの事前計算済みのモデルの読み込みは、SQL Server の機械学習では、特別なシリアル化アルゴリズムを使用して格納し、R とデータベースの間を移動するときに、モデルを読み込むため効率的です。

> [!TIP]
> SQL Server 2017、R がサーバーにインストールされていない場合でものスコアリングを実行するのに、PREDICT 関数を使用できます。 RevoScaleR パッケージから、限られたモデルの種類がサポートされます。

ただし、アルゴリズムに応じて使用する、モデルによって大きくなることが、特に大きなデータ セットでトレーニングする場合。 などのアルゴリズムなど、 **lm**または**glm**多数のルールと概要データを生成します。 Varbinary 列に格納できるモデルのサイズに制限があるため、実稼働環境用のデータベースにモデルを格納する前に、モデルから不要な成果物を排除することをお勧めします。

## <a name="articles-in-this-series"></a>この系列内のアーティクル

[パフォーマンス – R のチューニングの概要](../r/sql-server-r-services-performance-tuning.md)

[R - SQL Server の構成のパフォーマンスの調整](../r/sql-server-configuration-r-services.md)

[R の R のパフォーマンスの調整コードとデータの最適化](../r/r-and-data-optimization-r-services.md)

[パフォーマンスのチューニングのケース スタディ結果](../r/performance-case-study-r-services.md)
