---
title: "パラメーター化された行フィルター | Microsoft Docs"
ms.custom: ""
ms.date: "03/14/2017"
ms.prod: "sql-server-2016"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "replication"
ms.tgt_pltfrm: ""
ms.topic: "article"
helpviewer_keywords: 
  - "パブリケーション [SQL Server レプリケーション], 動的フィルター"
  - "マージ レプリケーション [SQL Server レプリケーション], 動的フィルター"
  - "パラメーター化されたフィルター [SQL Server レプリケーション]"
  - "フィルター [SQL Server レプリケーション], 動的"
  - "マージ レプリケーションのパラメーター化されたフィルター [SQL Server レプリケーション]"
  - "パブリケーション [SQL Server レプリケーション], パラメーター化されたフィルター"
  - "パラメーター化されたフィルター [SQL Server レプリケーション], パラメーター化されたフィルターについて"
  - "フィルター [SQL Server レプリケーション]、パラメーター化"
  - "動的フィルター [SQL Server レプリケーション]"
ms.assetid: b48a6825-068f-47c8-afdc-c83540da4639
caps.latest.revision: 69
author: "BYHAM"
ms.author: "rickbyh"
manager: "jhubbard"
---
# パラメーター化された行フィルター
  パラメーター化された行フィルターを使用すると、複数のパブリケーションを作成しなくても、パーティションの異なるデータを各サブスクライバーに送信できます (以前のバージョンの [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] では、パラメーター化されたフィルターは動的フィルターと呼ばれていました)。 パーティションとは、テーブル内の行のサブセットのことです。パラメーター化された行フィルターの作成時に選択した設定に基づき、パブリッシュされたテーブルの各行は、1 つのパーティションのみに属するか (重複しないパーティションが作成されます)、2 つ以上のパーティションに属します (重複するパーティションが作成されます)。  
  
 重複しないパーティションは、サブスクリプション間で共有するか、または 1 つのサブスクリプションのみが特定のパーティションを受け取るように制限することができます。 パーティションの動作を制御する設定については、このトピックの「適切なフィルター選択オプションの使用」で説明します。 これらの設定を使用すると、アプリケーションおよびパフォーマンスの要件に応じて、パラメーター化されたフィルター選択を調整できます。 一般に、重複するパーティションを使用すると柔軟性が向上し、重複しないパーティションを単一のサブスクリプションにレプリケートするとパフォーマンスが向上します。  
  
 パラメーター化されたフィルターは単一のテーブルで使用し、通常は関連するテーブルに対するフィルター選択を拡張するために結合フィルターと組み合わせて使用します。 詳しくは、「 [Join Filters](../../../relational-databases/replication/merge/join-filters.md)」をご覧ください。  
  
 を定義またはパラメーター化された行フィルターを変更するのには、を参照してください。 [を定義し、マージ アーティクルのパラメーター化された行フィルターを変更する](../../../relational-databases/replication/publish/define-and-modify-a-parameterized-row-filter-for-a-merge-article.md)です。  
  
## パラメーター化されたフィルターの動作  
 パラメーター化された行フィルターでは、WHERE 句を使用して、パブリッシュする適切なデータを選択します。 静的行フィルターのようにこの句でリテラル値を指定するのではなく、システム関数 SUSER_SNAME() および HOST_NAME() のいずれかまたは両方を指定します。 ユーザー定義関数も使用できますが、その場合はユーザー定義関数の本体に SUSER_SNAME() または HOST_NAME() を含めるか、または `MyUDF(SUSER_SNAME()` のように、ユーザー定義関数でこれらのシステム関数のいずれかを評価する必要があります。 ユーザー定義関数の本体に SUSER_SNAME() または HOST_NAME() を含める場合、その関数にパラメーターを渡すことはできません。  
  
 システム関数 SUSER_SNAME() および HOST_NAME() は、マージ レプリケーションに固有のものではありませんが、パラメーター化されたフィルター選択のためにマージ レプリケーションで使用されます。  
  
-   SUSER_SNAME() は、[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] のインスタンスに対する接続のログイン情報を返します。 この関数をパラメーター化されたフィルターで使用した場合、マージ エージェントがパブリッシャーに接続するために使用するログインが返されます (ログインはサブスクリプションを作成するときに指定します)。  
  
-   HOST_NAME() は、[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] のインスタンスに接続しているコンピューターの名前を返します。 この関数をパラメーター化されたフィルターで使用した場合、既定では、マージ エージェントが実行されているコンピューターの名前が返されます。 プル サブスクリプションの場合はサブスクライバーの名前になり、プッシュ サブスクリプションの場合はディストリビューターの名前になります。  
  
     サブスクライバーまたはディストリビューターの名前以外の値で、この関数をオーバーライドすることも可能です。 通常、アプリケーションでは、販売員の名前や ID など、より具体的な意味のある値でこの関数をオーバーライドします。 詳細については、このトピックの「HOST_NAME() 値のオーバーライド」を参照してください。  
  
 システム関数によって返された値は、フィルター選択しているテーブルで指定した列と比較され、適切なデータがサブスクライバーにダウンロードされます。 この比較は、サブスクリプションが初期化されたときに実行され (これにより初期スナップショットには適切なデータのみが含まれます)、またサブスクリプションが同期されるたびに実行されます。 既定では、パブリッシャーで変更の結果行が、パーティションから移動する場合、行は、サブスクライバーで削除 (を使用してこの動作を制御、 **@allow_partition_realignment** のパラメーター [sp_addmergepublication & #40 です。Transact-SQL と #41;](../../../relational-databases/system-stored-procedures/sp-addmergepublication-transact-sql.md))。  
  
> [!NOTE]  
>  パラメーター化されたフィルターの比較が実行されるときは、常にデータベース照合順序が使用されます。 たとえば、データベース照合順序で大文字と小文字が区別されず、テーブルまたは列の照合順序で大文字と小文字が区別される場合、比較では大文字と小文字は区別されません。  
  
### SUSER_SNAME() によるフィルター選択  
 検討してください、 **Employee テーブル** で、 [!INCLUDE[ssSampleDBCoShort](../../../includes/sssampledbcoshort-md.md)] サンプル データベース。 次の表に、列が含まれています **LoginID**, 、フォーム内の各従業員のログインを含む '*domain \login*' です。 このテーブルにフィルターを適用して、従業員が各自に関連するデータのみを受け取れるようにするには、フィルター句を次のように指定します。  
  
```  
LoginID = SUSER_SNAME()  
```  
  
 たとえば、ある従業員の値が 'adventure-works\john5' であるとします。 マージ エージェントはパブリッシャーに接続するときに、サブスクリプションの作成時に指定されたログインを使用します (この場合は 'adventure-works\john5')。 マージ エージェントは、テーブル内の値に SUSER_SNAME() によって返される値を比較しに 'adventure-works \john5' の値を含む行のみをダウンロード、 **LoginID** 列です。  
  
### HOST_NAME() によるフィルター選択  
 検討してください、 **HumanResources.Employee** テーブルです。 など、このテーブルに列が含まれていると仮定 **ComputerName** 形式で各従業員のコンピューターの名前で '*name_computertype*' です。 このテーブルにフィルターを適用して、従業員が各自に関連するデータのみを受け取れるようにするには、フィルター句を次のように指定します。  
  
```  
ComputerName = HOST_NAME()  
```  
  
 たとえば、ある従業員の値が 'john5_laptop' であるとします。 テーブル内の値を HOST_NAME() によって返された値と比較してに 'john5_laptop' の値を含む行のみをダウンロード、マージ エージェントがパブリッシャーに接続すると、 **ComputerName** 列です。  
  
 フィルターでは関数を組み合わせて使用することもできます。 たとえば、従業員が自分のコンピューターで自分のログインを使用している場合にのみデータを受け取れるようにするには、フィルター句を次のように指定します。  
  
```  
LoginID = SUSER_SNAME() AND ComputerName = HOST_NAME()  
```  
  
 HOST_NAME() の値をオーバーライドしている場合を除き、HOST_NAME() によるフィルター選択は、通常はプル サブスクリプションでのみ使用します。 この関数によって返される値は、マージ エージェントが実行されているコンピューターの名前です。 この値は、プル サブスクリプションの場合は各サブスクリプションによって異なりますが、プッシュ サブスクリプションの場合は同じです (プッシュ サブスクリプションの場合、すべてのマージ エージェントがディストリビューターで実行されます)。  
  
> [!IMPORTANT]  
>  HOST_NAME() 関数の値はオーバーライドされている場合があります。したがって、HOST_NAME() を含むフィルターを使用してデータのパーティションへのアクセスを制御することはできません。 データのパーティションへのアクセスを制御するには、SUSER_SNAME()、SUSER_SNAME() と HOST_NAME() の組み合わせ、または静的行フィルターを使用します。  
  
#### HOST_NAME() 値のオーバーライド  
 既に述べたとおり、HOST_NAME() は、既定では [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] のインスタンスに接続しているコンピューターの名前を返します。 パラメーター化されたフィルターを使用する場合、サブスクリプションの作成時に値を指定することによって、この値をオーバーライドすることがよくあります。 これにより、HOST_NAME() 関数は、コンピューターの名前ではなく、指定された値を返します。  
  
> [!NOTE]  
>  HOST_NAME() を上書きした場合、HOST_NAME() 関数のすべての呼び出しは、指定された値を返します。 他のアプリケーションが、コンピューター名を返す HOST_NAME() 関数に依存していないことを確認してください。  
  
 検討してください、 **HumanResources.Employee** テーブルです。 このテーブルには、列が含まれています。 **EmployeeID**します。 このテーブルにフィルターを適用して各従業員が関連データのみを受け取れるようにするには、フィルター句を次のように指定します。  
  
 `EmployeeID = CONVERT(int,HOST_NAME())`  
  
 たとえば、従業員の Pamela Ansman-Wolfe には、280 という従業員 ID が割り当てられています。 この従業員のサブスクリプションの作成時に、従業員 ID の値 (この場合は 280) を HOST_NAME() 値に指定します。 テーブル内の値を HOST_NAME() によって返された値と比較してに 280 という値を含む行のみをダウンロード、マージ エージェントがパブリッシャーに接続すると、 **EmployeeID** 列です。  
  
> [!IMPORTANT]  
>  HOST_NAME() 関数を返します、 **nchar** 値であるため、上記の例では、CONVERT フィルター句で列の場合は、数値データ型を使用する必要があります。 `CONVERT(nchar,EmployeeID) = HOST_NAME()` のように、パラメーター化された行フィルターの句で列名に関数を適用するとパフォーマンスが低下するため、使用しないことをお勧めします。 代わりに、この例で示されている `EmployeeID = CONVERT(int,HOST_NAME())` という句を使用することをお勧めします。 この句を使用できます、 **@subset_filterclause** のパラメーター [sp_addmergearticle](../../../relational-databases/system-stored-procedures/sp-addmergearticle-transact-sql.md), 、その通常では使用できませんパブリケーションの新規作成ウィザードが、(、ウィザードを実行して検証するのには、フィルター句に、コンピューター名を変換できないため失敗します、 **int**)。 指定することをお勧めパブリケーションの新規作成ウィザードを使用する場合 `CONVERT(nchar,EmployeeID) = HOST_NAME()` ウィザードとその後で使用で [sp_changemergearticle](../../../relational-databases/system-stored-procedures/sp-changemergearticle-transact-sql.md) に句を変更する `EmployeeID = CONVERT(int,HOST_NAME())` パブリケーションのスナップショットを作成する前にします。  
  
 **HOST_NAME() 値をオーバーライドするには**  
  
 以下のいずれかの方法で、HOST_NAME() 値をオーバーライドします。  
  
-   [!含める [ssManStudioFull] (../Token/ssManStudioFull_md.md)]: specify a value on the **HOST\_NAME\(\) Values** page of the New Subscription Wizard. For more information about creating subscriptions, see [Subscribe to Publications](../../../relational-databases/replication/subscribe-to-publications.md).  
  
-   レプリケーション [!INCLUDE[tsql](../../../includes/tsql-md.md)] プログラミング: の値を指定して、 **@hostname** のパラメーター [sp_addmergesubscription & #40 です。Transact SQL と #41;](../../../relational-databases/system-stored-procedures/sp-addmergesubscription-transact-sql.md) (プッシュ サブスクリプションの場合) または [sp_addmergepullsubscription_agent & #40 です。Transact SQL と #41;](../../../relational-databases/system-stored-procedures/sp-addmergepullsubscription-agent-transact-sql.md) (プル サブスクリプション用)。  
  
-   マージ エージェント: の値を指定する、 **-hostname** コマンドラインまたはエージェント プロファイルのパラメーターです。 マージ エージェントの詳細については、次を参照してください。 [レプリケーション マージ エージェント](../../../relational-databases/replication/agents/replication-merge-agent.md)します。 エージェント プロファイルの詳細については、次を参照してください。 [レプリケーション エージェント プロファイル](../../../relational-databases/replication/agents/replication-agent-profiles.md)します。  
  
## パラメーター化されたフィルターを使用したパブリケーションへのサブスクリプションの初期化  
 パラメーター化された行フィルターがマージ パブリケーションで使用される場合、レプリケーションは 2 つの要素から成るスナップショットを持つ各サブスクリプションを初期化します。 詳しくは、「 [Snapshots for Merge Publications with Parameterized Filters](../../../relational-databases/replication/snapshots-for-merge-publications-with-parameterized-filters.md)」をご覧ください。  
  
## 適切なフィルター選択オプションの使用  
 パラメーター化されたフィルターを使用する場合、制御できる主要な要素が 2 つあります。  
  
-   2 つのパブリケーション設定のいずれかで制御されているマージ レプリケーションによるフィルターを処理する方法: **パーティション グループを使用して** と **パーティションの変更を保持する**です。  
  
-   アーティクルの設定を反映する必要があるサブスクライバー間でデータを共有する方法 **パーティションのオプション**します。  
  
 フィルター オプションを設定するを参照してください。 [パラメーター化された行フィルターの最適化](../../../relational-databases/replication/publish/optimize-parameterized-row-filters.md)します。  
  
### "パーティション グループを使用" および "パーティションの変更を保持" の設定  
 両方の **パーティション グループを使用して** と **パーティションの変更を保持** オプションは、パブリケーション データベースで追加のメタデータを格納することでフィルター選択されたアーティクルを持つパブリケーションの同期のパフォーマンスを向上します。  **パーティション グループを使用して** オプションは、事前計算済みパーティション機能を使用してパフォーマンスが大幅に向上します。 このオプションが設定されている **true** 既定では、パブリケーションのアーティクルが一連の要件を満たしている場合。 これらの要件の詳細については、次を参照してください。 [事前計算済みパーティションを持つパラメーター化されたフィルター パフォーマンスの最適化](../../../relational-databases/replication/merge/optimize-parameterized-filter-performance-with-precomputed-partitions.md)します。 記事には、事前計算済みパーティションを使用するための要件を満たしていない場合、 **パーティションの変更を保持する** にするオプションが設定されている **true**します。  
  
### [パーティションのオプション] の設定  
 値を指定する、 **パーティションのオプション** プロパティ フィルター選択されたテーブル内のデータがサブスクライバーで共有する方法に従って、アーティクルを作成するときにします。 プロパティを使用して次の 4 つの値のいずれかに設定できます [sp_addmergearticle](../../../relational-databases/system-stored-procedures/sp-addmergearticle-transact-sql.md), 、[sp_changemergearticle](../../../relational-databases/system-stored-procedures/sp-changemergearticle-transact-sql.md), 、および **アーティクルのプロパティ** ] ダイアログ ボックス。 プロパティを使用して 2 つの値のいずれかに設定できます、 **フィルターの追加** または **フィルターの編集** パブリケーションの新規作成ウィザードから提供されているダイアログ ボックスおよび **パブリケーションのプロパティ** ] ダイアログ ボックス。 次の表は、利用可能な値をまとめたものです。  
  
|説明|[フィルターの追加] および [フィルターの編集] の値|[アーティクルのプロパティ] の値|ストアド プロシージャ内の値|  
|-----------------|-----------------------------------------|---------------------------------|--------------------------------|  
|パーティション内のデータは重複しています。サブスクライバーはパラメーター化されたフィルターで参照されている列を更新できます。|**[このテーブルの 1 行を複数のサブスクリプションに移動する]**|**[重複する]**|**0**|  
|パーティション内のデータは重複しています。サブスクライバーはパラメーター化されたフィルターで参照されている列を更新できません。|なし*|**[重複する (パーティション外のデータ変更を禁止)]**|**1**|  
|パーティション内のデータは重複していません。データはサブスクリプション間で共有されます。 サブスクライバーはパラメーター化されたフィルターで参照されている列を更新できません。|なし*|**[重複しない (複数のサブスクリプションで共有)]**|**2**|  
|パーティション内のデータは重複していません。パーティションごとに単一のサブスクリプションが存在します。 サブスクライバーはパラメーター化されたフィルターで参照されている列を更新できません。**|**[このテーブルの 1 行を 1 つのサブスクリプションのみに移動する]**|**[重複しない (単一のサブスクリプション)]**|**3**|  
  
 \*基になるフィルター選択オプションが設定されている場合 **0**, 、または **1**, 、または **2**, 、 **フィルターの追加** と **フィルターの編集** ] ダイアログ ボックスが表示 **このテーブルからの行に複数のサブスクリプションに移動する**です。  
  
 **このオプションを指定する場合、該当するアーティクル内のデータの各パーティションに対し、単一のサブスクリプションのみを使用できます。 第 2 のサブスクリプションを作成し、その新しいサブスクリプションのフィルター選択条件が既存のサブスクリプションと同じパーティションとして判別される場合、既存のサブスクリプションは削除されます。  
  
> [!IMPORTANT]  
>   **パーティションのオプション** 値は、サブスクライバーでデータを共有する方法に従って設定する必要があります。 たとえば、パーティションが重複せず、パーティションごとに単一のサブスクリプションが存在するように指定したにもかかわらず、データが別のサブスクライバーで更新された場合、マージ エージェントは同期中に失敗し、未集約が発生することがあります。  
  
#### 適切なパーティション オプションの選択  
 重複しないパーティションは事前計算済みパーティションと連動して、一部の機能上の制限が許容される状況でパフォーマンスを向上します。 事前計算済みパーティションを使用すると、サブスクライバーへのダウンロードの速度は向上しますが、アップロードの速度は低下します。 重複しないパーティションを使用すると、事前計算済みパーティションに関連するアップロードの負荷は最小限に抑えられます。 重複しないパーティションのパフォーマンス上の利点は、使用するパラメーター化されたフィルターと結合フィルターが複雑になるほど明確になります。  
  
 パブリケーションで使用するパーティション オプションを決めるときは、次のシナリオを検討してください。  
  
-   [!INCLUDE[ssSampleDBCoShort](../../../includes/sssampledbcoshort-md.md)] 特定の郵便に各販売員の顧客を担当する移動営業部門があります。 アプリケーションでは、顧客がある営業区域から別の営業区域に移動した場合に、郵便番号を更新し、その顧客が別の営業担当者に割り当てられるようにする必要があります。 パラメーター化されたフィルターは顧客の郵便番号に基づいています。更新により、該当する郵便番号が、ある営業担当者のパーティションから削除されて別の営業担当者のパーティションに挿入されます。 このためには、パラメーター化されたフィルターで参照されている列を更新する機能を持つ、重複するパーティションが必要です。 このオプションでは、柔軟性は最大になりますが、重複しないパーティションほどのパフォーマンスは得られない可能性があります。  
  
-   ある人材紹介会社では、州の各郡にある地域事務所にデータを提供しています。 このデータは重複していません。この会社の本社にあるテーブルの各行は、1 つのパーティションにのみ含まれていますが、そのパーティションは同じ郡にある複数の事務所に送信されます。 この場合、サブスクリプション間で共有されるパーティションに対して重複しないパーティション オプションを使用するのが適切です。これにより、重複するパーティションよりも高いパフォーマンスを実現しつつ、アプリケーションの要件を満たすことができます。  
  
-   重複しないパーティションを使用し、1 つのサブスクリプションだけが 1 つのパーティション内のデータを受信および更新する場合は、さらにパフォーマンスを向上させることができます。 このシナリオは、POS システムや、データが主にサブスクライバーで収集されてパブリッシャーにアップロードされるフィールド フォース アプリケーションで一般的です。 検討してください、 **パッケージ** 配信アプリケーション内のテーブル: で、パッケージのステータスを変更するように各パッケージは、トラックに積み込まれる、 **パッケージ** テーブル、および変更が本部にレプリケートします。 ドライバーは 2 つの異なるトラックで同じパッケージのステータスが更新されませんので、 **パッケージ** テーブルはパーティションごとに 1 つのサブスクリプションで重複しないパーティションに対する良い候補です。  
  
#### 重複しないパーティションに関する注意点  
 重複しないパーティションを使用するときは、以下の点に注意してください。  
  
##### 全般的な注意点  
  
-   パブリケーションでは事前計算済みパーティションを使用する必要があります。  
  
-   1 つの行は 1 つのパーティションにのみ属している必要があります。  
  
-   アーティクルを論理レコードの一部にすることはできません。  
  
-   代替同期パートナーはサポートされません (この機能は推奨されていません)。  
  
-   サブスクライバーはパラメーター化されたフィルターで参照されている列を更新できません。  
  
-   サブスクライバーでの挿入がパーティションに属さない場合、その挿入は削除されません。 ただし、他のサブスクライバーにはレプリケートされません。  
  
-   重複するパーティションを使用する一部の状況では、マージ エージェントがデータを挿入するときに、ID 範囲が調整されます。 重複しないパーティションでは、サブスクリプション データベースで ID 範囲を調整する権限を持つユーザーのみが、挿入時に範囲を調整できます。 ユーザーのテーブルを所有かのメンバーである必要があります、 **sysadmin** 固定サーバー ロール、 **db_owner** 固定データベース ロール、または **db_ddladmin** 固定データベース ロール。  
  
##### パーティションごとに単一のサブスクリプションが存在する重複しないパーティションに関するその他の注意点  
  
-   アーティクルは 1 つのパブリケーションにのみ存在することができます。アーティクルを再パブリッシュすることはできません。  
  
-   パブリケーションでは、サブスクライバーによるスナップショット処理の開始を許可する必要があります。 詳しくは、「 [Snapshots for Merge Publications with Parameterized Filters](../../../relational-databases/replication/snapshots-for-merge-publications-with-parameterized-filters.md)」をご覧ください。  
  
##### 結合フィルターに関するその他の注意点  
  
-   結合フィルター階層では、重複するパーティションのアーティクルを、重複しないパーティションのアーティクルよりも上位にすることはできません。 つまり、子アーティクルで重複しないパーティションを使用する場合、親アーティクルでも重複しないパーティションを使用する必要があります。 結合フィルターについては、次を参照してください。 [結合フィルター](../../../relational-databases/replication/merge/join-filters.md)します。  
  
-   結合フィルターが重複しないパーティション子である必要がありますが、 **結合一意キー** プロパティが 1 に設定します。 詳しくは、「 [Join Filters](../../../relational-databases/replication/merge/join-filters.md)」をご覧ください。  
  
-   アーティクルは、1 つのパラメーター化されたフィルターまたは結合フィルターのみを持っている必要があります。 パラメーター化されたフィルターを持ち、かつ結合フィルターの親になることは可能です。 パラメーター化されたフィルターを持ち、かつ結合フィルターの子になることはできません。 複数の結合フィルターを持つことはできません。  
  
-   パブリッシャーの 2 つのテーブルに結合フィルター リレーションシップがあり、子テーブルの行が親テーブルの行と対応していない場合、その行を親テーブルに挿入しても、関連する行はサブスクライバーにダウンロードされません (行は重複するパーティションによってダウンロードされます)。 などの場合、 **salesorderdetail の各** テーブルがない対応する行の行を含む、 **SalesOrderHeader** に存在しない行を挿入して、テーブル **SalesOrderHeader**, 行が、サブスクライバーにダウンロードされますが、行、対応する、 **salesorderdetail の各** されません。  
  
## 参照  
 [時間ベースの行フィルターの推奨事項](../../../relational-databases/replication/merge/best-practices-for-time-based-row-filters.md)   
 [パブリッシュされたデータのフィルター選択](../../../relational-databases/replication/publish/filter-published-data.md)   
 [マージ レプリケーション用にパブリッシュされたデータのフィルター選択](../../../relational-databases/replication/merge/filter-published-data-for-merge-replication.md)  
  
  