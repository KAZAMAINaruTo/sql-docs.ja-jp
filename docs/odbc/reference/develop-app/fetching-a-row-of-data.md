---
title: "データの行をフェッチ |Microsoft ドキュメント"
ms.custom: 
ms.date: 01/19/2017
ms.prod: sql-non-specified
ms.reviewer: 
ms.suite: 
ms.technology:
- drivers
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- SQLFetch function [ODBC], fetching a row of data
- cursors [ODBC], fetching rows
- result sets [ODBC], fetching
- fetches [ODBC], row of data
ms.assetid: 16d4a380-0d83-456b-aeee-f10738944e86
caps.latest.revision: 5
author: MightyPen
ms.author: genemi
manager: jhubbard
ms.translationtype: MT
ms.sourcegitcommit: f7e6274d77a9cdd4de6cbcaef559ca99f77b3608
ms.openlocfilehash: 142c9a2c95900e5b3776f96d86a145defc447512
ms.contentlocale: ja-jp
ms.lasthandoff: 09/09/2017

---
# <a name="fetching-a-row-of-data"></a>データの行のフェッチ
アプリケーションを呼び出すデータの行をフェッチする**SQLFetch**です。 **SQLFetch**をカーソルの種類と呼ばれることができますが、順方向専用の方向に行セットのカーソルだけ移動します。 **SQLFetch**次の行にカーソルを移動し、データへの呼び出しにバインドされていたすべての列を返します**SQLBindCol**です。 設定すると、カーソルが結果の末尾に達したとき、 **SQLFetch** SQL_NO_DATA が返されます。 例については、呼び出し元の**SQLFetch**を参照してください[を使用して SQLBindCol](../../../odbc/reference/develop-app/using-sqlbindcol.md)です。  
  
 正確にどのように**SQLFetch**は実装は、ドライバー固有では、一般的なパターンでは、ドライバーのいずれかのデータ ソースから列をバインド、バインドされた変数の型に応じた変換し、データを取得する、これらの変数に変換後のデータ。 ドライバーは、すべてのデータを変換できない場合**SQLFetch**はエラーを返します。 アプリケーションは、行のフェッチを続行できますが、現在の行のデータは失われます。 バインドされていない列のデータを操作結果、ドライバーによって異なりますが、ほとんどのドライバーを取得し、破棄またはまったく取得しません。  
  
 ドライバーでは、バインドされている任意の長さ/インジケーター バッファーの値も設定します。 列のデータ値が NULL の場合、ドライバーは SQL_NULL_DATA に対応する長さ/インジケーター バッファーを設定します。 データ値が NULL でない場合、ドライバーは、変換後に、データのバイト長を長さ/インジケーター バッファーを設定します。 この長さを特定できないように 2 つ以上の関数呼び出しによって取得される長い形式のデータの場合、ドライバーは SQL_NO_TOTAL を長さ/インジケーター バッファーを設定します。 整数や日付構造体などの固定長データ型のバイトの長さは、データ型のサイズです。  
  
 ドライバーが、変換されたデータに対して、列にバインドされるバッファーのバイト長のバイト長をチェックする文字とバイナリ データなどの可変長データについてバッファーの長さが指定された、 *BufferLength*引数**SQLBindCol**です。 ドライバーが、バッファーに収まらないデータが切り捨てられます、切り詰められていない長さ/インジケーター バッファーの長さが、sql_success_with_info が返されます、SQLSTATE 01004 (データの配置を返します変換後のデータのバイト長が、バッファーのバイト長よりも大きい場合は、切り捨てられます)、診断します。 唯一の例外は、によって返されるときに、可変長のブックマークが切り捨てられるかどうか**SQLFetch**、SQLSTATE 22001 (文字列データの右側が切り捨てられました) が返されます。  
  
 固定長のデータが切り捨てられなければ、ドライバーは、バインドされたバッファーのサイズがデータ型のサイズであると見なすためです。 データの切り捨ては、アプリケーションは通常、全体のデータ値を保持するのに十分な大きさのバッファーをバインドするために、まれである傾向があります。メタデータから必要なサイズを決定します。 ただし、アプリケーションは、バッファーが小さすぎることを知っているを明示的に連結する場合があります。 たとえばを取得し、表示する部分の説明の最初の 20 文字か長いテキスト列の最初の 100 個の文字に可能性があります。  
  
 文字データがあります、ドライバーによって null で終わる、アプリケーションに返される前に場合でもが切り捨てられました。 Null 終端文字は返されるバイトの長さに含まれていないが、バインドされたバッファー内の領域は必要です。 たとえば、アプリケーションは、ASCII 文字セット内の文字データで構成される文字列を使用して、ドライバーが 50 文字を返すには、データおよびアプリケーションのバッファーが 25 バイト長。 アプリケーションのバッファーでは、ドライバーは、最初の 24 文字の後に、null 終端文字を返します。 長さ/インジケーター バッファー 50 バイトの長さを返します。  
  
 アプリケーションでは、設定、結果を作成するステートメントを実行する前に SQL_ATTR_MAX_ROWS ステートメント属性を設定して、結果セット内の行の数を制限できます。 たとえば、レポートを書式設定に使用するアプリケーションでプレビュー モードでは、レポートの最初のページを表示するための十分なデータのみが必要です。 結果セットのサイズを制限するでは、このような機能が高速に実行されます。 このステートメント属性は、ネットワーク トラフィックを削減するためのものし、すべてのドライバーでサポートされていない可能性があります。
