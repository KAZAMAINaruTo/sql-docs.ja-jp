---
title: 配置 |Microsoft ドキュメント
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.suite: sql
ms.technology: connectivity
ms.tgt_pltfrm: ''
ms.topic: conceptual
helpviewer_keywords:
- alignment issues [ODBC]
ms.assetid: 06a01e51-e7a5-495f-aa27-e304b0d005ff
caps.latest.revision: 8
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: 09460dee5104baad7168839449d10bf36845b22f
ms.sourcegitcommit: 1740f3090b168c0e809611a7aa6fd514075616bf
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/03/2018
---
# <a name="alignment"></a>Alignment
ODBC アプリケーションで配置の問題は一般にまったく同じ、他のアプリケーションよりも。 つまり、ほとんどの ODBC アプリケーションでは、配置にほとんどまたはまったくの問題があります。 処罰のアドレスを配置できませんハードウェアとオペレーティング システムでさまざまであり、わずかなパフォーマンスの低下としてとしてマイナーまたは実行時の致命的なエラーとして、メジャーがあります。 したがって、ODBC アプリケーション、およびポータブルの ODBC アプリケーション具体的には、する必要がありますデータを正しく整列するように注意します。  
  
 1 つの ODBC アプリケーションが配置の問題を検出すると例が大きなメモリ ブロックを割り当てます、そのメモリのさまざまな部分を結果セット内の列にバインドされる場合。 実行時に、結果セットの形状を決定しを割り当て、それに応じてメモリをバインドする必要があります、汎用アプリケーションときに発生する可能性があります。  
  
 たとえば、アプリケーションを実行、**選択**ステートメントは、ユーザーが入力し、このステートメントから結果をフェッチします。 不明なためこの結果セットの形状、プログラムに書き込まれると、アプリケーションは結果セットを作成した後、各列の型を決定し、それに応じてメモリをバインドする必要があります。 これを行う最も簡単な方法では、メモリの大きなブロックを割り当てるし、そのブロック内の各列に別のアドレスをバインドします。 列のデータにアクセスするには、アプリケーションは、その列にバインドされているメモリをキャストします。  
  
 次の図は、設定し、各 SQL データ型の既定の C データ型を使用してメモリ ブロックをバインドする方法、サンプルの結果を示します。 各"X"では、メモリの 1 バイトを表します。 (この例は、列にバインドされているデータ バッファーのみを示します。 これはわかりやすくするためです。 実際のコードで、長さ/インジケーター バッファーする必要がありますで配置されます。)  
  
 ![SQL データ型に既定の C データ型によるバインド](../../../odbc/reference/develop-app/media/pr24.gif "pr24")  
  
 格納されているがバインド アドレスと仮定した場合、*アドレス*配列、アプリケーションを使用して、次の式の各列にバインドされているメモリにアクセスします。  
  
```  
(SQLCHAR *)       Address[0]  
(SQLSMALLINT *)   Address[1]  
(SQLINTEGER *)    Address[2]  
```  
  
 2 番目のアドレスにバインドされていることと 3 番目の列が奇数バイトの開始され、アドレスが 3 番目の列にバインドされているが分割できないアイテム 4 で、これは、SDWORD のサイズによって確認します。 いくつかのコンピューターでは、これは問題になりません、です。他のユーザーのおそれがある、わずかなパフォーマンスが低下します。まだ他のユーザーに致命的な実行時エラーが発生、されます。 自然な配置境界にバインドされている各アドレスを整列することをお勧めします。 これは、1 UCHAR、SWORD、2 および 4 は、SDWORD を想定して"X"が使用されるメモリのバイトを表し、"O"が使用されていないメモリのバイトを表し、次の図に示すように結果を得るため、この。  
  
 ![自然な配置境界によるバインド](../../../odbc/reference/develop-app/media/pr25.gif "pr25")  
  
 このソリューションでは、すべてのアプリケーションのメモリ使用していない、すべての配置の問題が見つかりませんしません。 残念ながら、そのがかかります、相当量のこのソリューションを実装するコードの種類に応じて、各列を個別に配置する必要があります。 すべての列の最大の配置の境界は 4 は、サイズに合わせて簡単なソリューションは、次の図に示した例でします。  
  
 ![最大の配置境界によるバインド](../../../odbc/reference/develop-app/media/pr26.gif "pr26")  
  
 このソリューションより大きな穴を残します、それを実装するコードが比較的単純で高速です。 ほとんどの場合は、未使用のメモリ内で、パフォーマンス低下をオフセットします。 このメソッドを使用する例は、次を参照してください。[を使用して SQLBindCol](../../../odbc/reference/develop-app/using-sqlbindcol.md)です。
