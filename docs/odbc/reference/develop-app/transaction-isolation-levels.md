---
title: "トランザクション分離レベル |Microsoft ドキュメント"
ms.custom: 
ms.date: 01/19/2017
ms.prod: sql-non-specified
ms.prod_service: drivers
ms.service: 
ms.component: odbc
ms.reviewer: 
ms.suite: sql
ms.technology: drivers
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- dirty reads [ODBC]
- isolation levels [ODBC]
- nonrepeatable reads [ODBC]
- read uncommitted [ODBC]
- read committed [ODBC]
- serializable reads [ODBC]
- phantoms [ODBC]
- transaction isolation [ODBC]
- repeatable reads [ODBC]
- transactions [ODBC], isolation
ms.assetid: 0d638d55-ffd0-48fb-834b-406f466214d4
caps.latest.revision: "6"
author: MightyPen
ms.author: genemi
manager: jhubbard
ms.workload: On Demand
ms.openlocfilehash: 1d19973db310faafd97d9ab6c38848395a344100
ms.sourcegitcommit: cc71f1027884462c359effb898390c8d97eaa414
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/21/2017
---
# <a name="transaction-isolation-levels"></a>トランザクション分離レベル
*トランザクション分離レベル*分離が成功するトランザクションにエクステントの指標です。 具体的には、トランザクション分離レベルは、次の現象の有無によって定義されます。  
  
-   **ダーティ リード**A*ダーティ リード*トランザクションがまだコミットされていないデータを読み取るときに発生します。 たとえば、トランザクション 1 更新プログラムを行とします。 トランザクション 2 は、トランザクション 1 が、更新をコミットする前に、更新された行を読み取ります。 トランザクション 1 は、変更をロールバック場合、トランザクション 2 は読み取りと見なされることはありませんが存在するデータです。  
  
-   **反復不能読み取り**A*反復不能読み取り*トランザクションが同じ行を 2 回読み取りますが、たびに異なるデータを取得するときに発生します。 たとえば、トランザクション 1 読み取りを行とします。 トランザクション 2 は、更新またはその行を削除し、更新または削除をコミットします。 トランザクション 1 が、行を再読み込みする場合は別の行の値を取得または行が削除されたことを検出します。  
  
-   **ファントム**A*ファントム*は検索条件に一致が最初に認識されない行です。 たとえば、トランザクション 1 が一部の検索条件に適合する行のセットを読み取ります。 トランザクション 2 は、トランザクション 1 の検索条件に一致する (またはどちらかを通じて、update、insert) の新しい行を生成します。 トランザクション 1 では、行を読み取り、ステートメントを reexecutes 場合、異なる一連の行を取得します。  
  
 4 つのトランザクション分離レベルで定義された SQL 92) は、これらの現象の観点から定義されます。 次の表では、"X"は、発生する可能性がそれぞれの現象をマークします。  
  
|トランザクション分離レベル|ダーティ リード|反復不能読み取り|ファントム|  
|---------------------------------|-----------------|-------------------------|--------------|  
|READ UNCOMMITTED|×|×|×|  
|読み取りのコミット|--|×|×|  
|REPEATABLE READ|--|--|×|  
|Serializable|--|--|--|  
  
 次の表では、DBMS が、トランザクション分離レベルを実装が簡単な方法について説明します。  
  
> [!IMPORTANT]  
>  ほとんどの Dbms では、他にもより複雑なスキームを使用して、同時実行制御を向上します。 これらの例は、わかりやすくするためだけに提供されます。 ODBC ではどのように特定の Dbms に規定いない具体的には、個々 のトランザクションは分離します。  
  
|トランザクションの分離|可能な実装|  
|---------------------------|-----------------------------|  
|READ UNCOMMITTED|トランザクションが互いから分離されていません。 DBMS では、他のトランザクション分離レベルをサポートする場合、それらのレベルの実装を使用してどのようなメカニズムを無視します。 これらは悪影響を与えることに影響しないように他のトランザクション、Read Uncommitted レベルで実行されているトランザクションは読み取り専用通常を使用します。|  
|読み取りのコミット|他のトランザクションによる書き込みロックされた行のロックが解除されるまで、トランザクションが待機します。このできなくなります「ダーティ」データの読み取り。<br /><br /> (行の読み取りしか行わない) 場合、読み取りロックまたは書き込みロック (更新または行を削除する) 場合、現在の行を他のトランザクションが更新または削除することを防ぐためにトランザクションを保持します。 トランザクションは、現在の行を非表示を移動するときに、読み取りロックを解放します。 コミットまたはロールバックされるまでは、書き込みロックを保持します。|  
|REPEATABLE READ|他のトランザクションによる書き込みロックされた行のロックが解除されるまで、トランザクションが待機します。このできなくなります「ダーティ」データの読み取り。<br /><br /> トランザクションでは、すべての行を挿入、更新、または削除、アプリケーションと書き込みのロックを返しますのすべての行で読み取りロックを保持します。 たとえば、トランザクションには、SQL ステートメントが含まれています。**選択\*から注文**、トランザクション読み取りロック アプリケーションをフェッチする行。 トランザクションには、SQL ステートメントが含まれている場合**削除からの注文が状態 'CLOSED' の =**トランザクションの書き込みロックを削除する行。<br /><br /> 他のトランザクションは、更新または、これらの行を削除できません、ため、現在のトランザクションは、反復不能読み取りを回避できます。 トランザクションは、コミットまたはロールバック時に、そのロックを解放します。|  
|Serializable|他のトランザクションによる書き込みロックされた行のロックが解除されるまで、トランザクションが待機します。このできなくなります「ダーティ」データの読み取り。<br /><br /> (行の読み取りしか行わない) 場合、トランザクションが読み取りロックを保持または書き込みロック (更新または行の削除) 場合の範囲にその行に影響します。 例では、トランザクションには、SQL ステートメントが含まれている場合の**選択\*から注文**範囲は、全体 Orders テーブル以外のトランザクション読み取りロックは、テーブルの場合は、新しい行を挿入するのには許可しません。 トランザクションには、SQL ステートメントが含まれている場合**削除からの注文が状態 'CLOSED' の =**範囲は、"CLOSED"のステータスを持つすべての行以外のトランザクションの書き込みロックの注文のすべての行の表に"CLOSED"ありの状態でないです。すべての行を挿入または更新された結果の行がある"CLOSED"の状態を許可します。<br /><br /> 他のトランザクションは、更新または範囲の行を削除できません、ため、現在のトランザクションは、反復不能読み取りを回避できます。 他のトランザクションは、範囲の任意の行を挿入することはできません、ため、現在のトランザクションは、ファントムを回避できます。 トランザクションは、コミットまたはロールバック時にロックを解放します。|  
  
 トランザクション分離レベルが、独自の変更を表示するトランザクションの機能に影響を及ぼさないように注意してください。トランザクションでは、変更することが常に表示します。 たとえば、トランザクションは、2 つの構成可能性があります**更新**ステートメントの最初の 10% ですべての従業員の給与を発生させるし、2 番目がその容量を最大程度経由で任意の従業員の給与を設定します。 成功すると、単一のトランザクションとしてだけであるため、2 つ目**更新**ステートメントは、最初の結果を確認できます。
